### 1.SPRING MVC 提供了基于注解的控制器开发模式，请说明一下注解的作用
@RestController
@PathVariable
@RequestBody
@ResponseBody
@SessionAttribute
@ModelAttribute

#### @RestController
它用于返回JSON、XML等数据，但不能返回HTML页面。作用相当于@ResponseBody加@Controller。
#### @PathVariable
使用@PathVariable可以快速的访问URL中的部分内容，一个方法可以有多个@PathVariable注解，它还可以使用在map参数上，但必须配置<mvc:annotation-driven>，使用它可以让我们进行REST风格的变成，简单理解REST：对网络中某一资源的操作使用一个URI进行表示，然后使用状态来（GET、POST、PUT、DELETE）表示某种操作。
#### @RequestBody
它常用来处理JSON/XML格式的数据。通过@RequestBody可以将请求体中的（JSON/XML）字符串绑定到相应的Bean上，也可以将其分别绑定到对应的字符串上。GET方式无请求体，所以使用它接收数据时，前端不能使用GET方式提交数据，而是使用POST方式进行提交。在后端的同一个接收方法里，@RequestBody与@RequestParm()可以同时使用，但@RequestBody最多只能有一个，而@RequestParam()可以有多个。
#### @ResponseBody
将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。
#### @SessionAttribute
该注解作用在方法上或者方法的参数上，表示将被注解的方法的返回值或者是被注解的参数作为Model的属性加入到Model中，然后Spring框架自会将这个Model传递给ViewResolver。Model的生命周期只有一个http请求的处理过程，请求处理完后，Model就销毁了，如果想让参数在多个请求间共享，那么可以用到@SessionAttribute注解
#### @ModelAttribute
该注释最主要的作用是将数据添加到模型对象中，用于视图页面展示时使用。注释在参数上，会将客户端传递过来的参数按名称注入到指定对象种，并且会将这个对象自动加入ModelMap中；注视在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中。
### 2.DispatcherServlet常被称为SpringMVC的心脏，在文档的1.1.5节介绍了DispatcherServlet处理一个请求的流程，请求根据该段描述并查阅相关资料，描述一下自己理解的DispathcerServlet处理一个请求的流程。
①客户向服务器发送HTTP请求，请求被前端控制器DispatcherServlet捕获，DispatcherServlet根据-servlet.xml中的配置队请求的URL进行解析，得到请求资源标识符（URI）。再根绝URL调用HandlerMapping获得该Handler配置的所有相关的对象（包裹Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的新式返回。
②根据获得的Handler，选择一个合适的HandlerAdapter，提取Request中的数据模型，填充Handler入参，开始执行Controller。
③Controller执行完成后，向DispatcherServlet返回一个ModelAndView对象，根据返回的ModelAndView，选择一个合适的ViewResolver返回给DispatcherServlet，ViewResolver结合ModelAndView来渲染视图，视图负责将渲染结果返回给客户端。

其中如果指定multipart file resolver，请求将会multiparts审查，如果multiparts找到了，则请求被其他部分处理。
如果返回Model则呈现View，如果没有返回任何Model，则不呈现视图。
声明的beans将处理那些在处理请求过程中跑出的异常，这些异常解析器允许自定义逻辑以解决异常。

### 3.面向Web开发的MVC框架种类繁多，请查阅资料对Spring MVC和其它一种MVC框架（如struts2）进行对比
SpringMVC是基于方法开发的，而struts2是基于类开发的，SpringMVC一个方法对应一个request的上下文，而方法同时又跟一个url对应；struts2则是一个类对应一个request上下文，其中的Action的一个方法可以对应一个url，而类属性却被左右方法共享，这就无法使用注解或者其他方式表示其所述方法。
SpringMVC的方法之间基本上是独立的，独享request response的数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，Struts2虽然方法之间式独立的，但所有的Action变量是共享的，导师编码过程相对于SpringMVC更加复杂，并且要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个个Map，供给每个Action使用，并要保证线程安全，因此在原则上是比较耗费内存的。
在拦截器实现机制上，Struts2有自己的interceptor机制，SpringMVC使用的是独立的AOP方式，导致Struts2的配置文件量比SpringMVC更大。
SpringMVC可以进行单例开发，并且建议使用单例开发，struts2通过类的成员变量接受参数，无法使用单例，只能使用多例。